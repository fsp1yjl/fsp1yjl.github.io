<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="数据结构,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="在上一篇中，说了B-Tree的定义以及Google 一个btree包的一些信息， 这里根据阅读其源代码的理解，实现一个简化版的B-Tree插入操作。 Google的那个golang版本的btree包在应对gc和并发读写(copy on write)操作方面做了很多优化，这里我在实现的时候，先忽略这些，只是先实现核心的数据操作部分，不过对于一个生产包来说，gc和并发操作却是是要不得不考虑的事情">
<meta name="keywords" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="由一个golang的B-Tree包展开-2(插入)">
<meta property="og:url" content="http://yoursite.com/2018/12/25/201812btree-2/index.html">
<meta property="og:site_name" content="不知火">
<meta property="og:description" content="在上一篇中，说了B-Tree的定义以及Google 一个btree包的一些信息， 这里根据阅读其源代码的理解，实现一个简化版的B-Tree插入操作。 Google的那个golang版本的btree包在应对gc和并发读写(copy on write)操作方面做了很多优化，这里我在实现的时候，先忽略这些，只是先实现核心的数据操作部分，不过对于一个生产包来说，gc和并发操作却是是要不得不考虑的事情">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-12-29T05:15:43.775Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="由一个golang的B-Tree包展开-2(插入)">
<meta name="twitter:description" content="在上一篇中，说了B-Tree的定义以及Google 一个btree包的一些信息， 这里根据阅读其源代码的理解，实现一个简化版的B-Tree插入操作。 Google的那个golang版本的btree包在应对gc和并发读写(copy on write)操作方面做了很多优化，这里我在实现的时候，先忽略这些，只是先实现核心的数据操作部分，不过对于一个生产包来说，gc和并发操作却是是要不得不考虑的事情">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/12/25/201812btree-2/">





  <title> 由一个golang的B-Tree包展开-2(插入) | 不知火 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2519991216496e1fcf56707e51436dd2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不知火</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/201812btree-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="不知火">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://img3.doubanio.com/icon/ul54452955-3.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知火">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                由一个golang的B-Tree包展开-2(插入)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-25T21:23:20+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index">
                    <span itemprop="name">golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/25/201812btree-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/12/25/201812btree-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在上一篇中，说了B-Tree的定义以及Google 一个btree包的一些信息， 这里根据阅读其源代码的理解，实现一个简化版的B-Tree插入操作。</p>
<p>Google的那个golang版本的btree包在应对<strong>gc</strong>和<strong>并发读写</strong>(copy on write)操作方面做了很多优化，这里我在实现的时候，先忽略这些，只是先实现核心的数据操作部分，不过对于一个生产包来说，gc和并发操作却是是要不得不考虑的事情</p>
<a id="more"></a>
<p><a href="https://github.com/fsp1yjl/btree" target="_blank" rel="noopener">参考google/btree的精简版代码</a></p>
<h3 id="B-Tree结构定义及初始化"><a href="#B-Tree结构定义及初始化" class="headerlink" title="B-Tree结构定义及初始化"></a>B-Tree结构定义及初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个btree的定义结构包括其节点最少度树degree，它决定了每个node可以包括多少键值信息</span></span><br><span class="line"><span class="comment">// root表示根节点</span></span><br><span class="line"><span class="keyword">type</span> BTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	degree <span class="keyword">uint</span></span><br><span class="line">	root   *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node代表btree的一个节点</span></span><br><span class="line"><span class="comment">//一个节点包含了一组排序存放的items，以及子节点的指针数组</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	items    Items</span><br><span class="line">	children children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children类型是指向node节点类型的指针数组</span></span><br><span class="line"><span class="keyword">type</span> children []*node</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Item是一个接口类型，含有一个Less方法，通过这个接口可以实现类似泛型的功能。</span></span><br><span class="line"><span class="keyword">type</span> Items []Item</span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">interface</span> &#123;</span><br><span class="line">	Less(than Item) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里就可以使用IntItem(3)初始化出一个Item类型的变量，因为IntItem实现了Item接口的方法。</span></span><br><span class="line"><span class="keyword">type</span> IntItem <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Less returns true if int(a) &lt; int(b).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a IntItem)</span> <span class="title">Less</span><span class="params">(b Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b.(IntItem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的初始化btree方法如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一棵空树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTree</span><span class="params">(degree <span class="keyword">uint</span>)</span> *<span class="title">BTree</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;BTree&#123;</span><br><span class="line">		degree: degree,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="B-Tree中插入新数据"><a href="#B-Tree中插入新数据" class="headerlink" title="B-Tree中插入新数据"></a>B-Tree中插入新数据</h3><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tr := t.NewTree(<span class="number">2</span>) <span class="comment">//初始化一棵最小度为2的树，即2-3-4树，4阶树</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">item := t.IntItem(v) <span class="comment">// int 类型转换为IntItem类型</span></span><br><span class="line">tr.ReplaceOrInsert(item)</span><br></pre></td></tr></table></figure>
<h4 id="插入的思路"><a href="#插入的思路" class="headerlink" title="插入的思路"></a>插入的思路</h4><p>思路：<br>总结起来就是：所有插入都由根向下递归查询，最终找到合适的叶子节点插入，对递归沿途经过的已满节点，进行分裂操作，保证最终插入的叶子节点非满。</p>
<p>插入从跟节点开始进行二分查询，向下递归，知道找到合适的叶子节点进行插入。 在递归向下的过程中，为了不破坏btree的规则，即 len(item) &lt; 2t-1,每次向下递归的目标子树 len(node.children[i].items) 已满的时候，就对node进行一次分裂，保证分裂后的node.children[i].items元素个数小于2t-1.<br>具体的分裂做法： 由于node.children[i].items的值是单调递增的， 将node.children[i]从中间截断，形成两个node, left_node, right_node,各自拿到原node中items, children的前一半和后一半，并将node.children[i].items最中间那个提出，插入到放到 node.items[i]到位置。 left_node,right_node则作为两个新子节点，替换node.children[i]原本到位置<br>这样，与分裂前比起来， node.items元素增加了一个， node.children元素也增加了一个，并不会破坏btree的性质。 从经过分裂之后到节点进行插入操作，就可以顺利递归下沉到子树，直到到达叶子节点（进入叶子节点前，该节点也必然已经经历了分裂检查，所以必然是未满节点），进行插入。<br>当然，每次对node.items进行二分查询定位是，如果发现要插入到元素已经存在，则不进行插入操作，直接返回原内通。</p>
<p>。。。 此处应该有图形展示，稍等，等我找到合适的图床，我就上图，没有图文并茂，十分抱歉。。。 <a href="#demo">凑合看的插入演示。。。</a></p>
<h4 id="配套函数"><a href="#配套函数" class="headerlink" title="配套函数"></a>配套函数</h4><p>从上面到表述中，已经看到，在每一层节点进行查询时，都要进行一个二分查询定位到操作,这个查询定位的find函数功能如下：<br>在一个生序排列到数组中，查询目标元素， 如果元素存在，则返回目标元素在数组中索引和元素找到到flag标志，如果元素不存在，则返回第一个大于目标元素到数组索引。 比如[1,3,5]中查询1则返回（0，true）， 查询4则返回[2, false]。</p>
<p>代码如下,可以看出主要调用了golang 基础包sort提供的Search方法, 从描述中我们可以看出，search方法使用二分搜索去返回元素中最小的满足[0,n)中最小的满足f(i)函数为true的索引i，如果f(i)为true，则f(i+1)也为true。 这里的f()需要我们自定义传入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(items Items)</span> <span class="title">find</span><span class="params">(t Item)</span> <span class="params">(index <span class="keyword">int</span>, found <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	i := sort.Search(<span class="built_in">len</span>(items), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.Less(items[i])</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; !items[i<span class="number">-1</span>].Less(t) &#123;</span><br><span class="line">		<span class="keyword">return</span> i - <span class="number">1</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sort.Search<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search uses binary search to find and return the smallest index i</span></span><br><span class="line"><span class="comment">// in [0, n) at which f(i) is true, assuming that on the range [0, n),</span></span><br><span class="line"><span class="comment">// f(i) == true implies f(i+1) == true. That is, Search requires that</span></span><br><span class="line"><span class="comment">// f is false for some (possibly empty) prefix of the input range [0, n)</span></span><br><span class="line"><span class="comment">// and then true for the (possibly empty) remainder; Search returns</span></span><br><span class="line"><span class="comment">// the first true index. If there is no such index, Search returns n.</span></span><br><span class="line"><span class="comment">// (Note that the "not found" return value is not -1 as in, for instance,</span></span><br><span class="line"><span class="comment">// strings.Index.)</span></span><br><span class="line"><span class="comment">// Search calls f(i) only for i in the range [0, n).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// Define f(-1) == false and f(n) == true.</span></span><br><span class="line">	<span class="comment">// Invariant: f(i-1) == false, f(j) == true.</span></span><br><span class="line">	i, j := <span class="number">0</span>, n</span><br><span class="line">	<span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">		h := <span class="keyword">int</span>(<span class="keyword">uint</span>(i+j) &gt;&gt; <span class="number">1</span>) <span class="comment">// avoid overflow when computing h</span></span><br><span class="line">		<span class="comment">// i ≤ h &lt; j</span></span><br><span class="line">		<span class="keyword">if</span> !f(h) &#123;</span><br><span class="line">			i = h + <span class="number">1</span> <span class="comment">// preserves f(i-1) == false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			j = h <span class="comment">// preserves f(j) == true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.</span></span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="插入逻辑实现"><a href="#插入逻辑实现" class="headerlink" title="插入逻辑实现"></a>插入逻辑实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">ReplaceOrInsert</span><span class="params">(item Item)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果是空树，则创建根后插入</span></span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.root = t.newNode()</span><br><span class="line">		t.root.items = <span class="built_in">append</span>(t.root.items, item)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从跟节点向下寻找合适的插入节点，对于新的item，最终的插入会落到叶子节点，</span></span><br><span class="line">	<span class="comment">// 下降过程中，每个经过的节点如果已满，聚会进行一次分裂动作，</span></span><br><span class="line">	<span class="comment">// 这样保证后续插入的时候，实际插入的节点肯定会有空闲空间供插入</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对有可能改变根节点的情况进行单独处理</span></span><br><span class="line">	<span class="comment">// 如果根结点已满，对根节点进行分裂处理</span></span><br><span class="line">	<span class="comment">// 这里的MaxCap返回的是每个节点子树的最大树木，对于4阶树就是4</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(t.root.items) &gt;= t.MaxCap() &#123;</span><br><span class="line">		midIndex := <span class="built_in">len</span>(t.root.items) / <span class="number">2</span></span><br><span class="line">		upItem, newNode := t.root.split(midIndex)</span><br><span class="line">		newRoot := t.newNode()</span><br><span class="line">		newRoot.items = <span class="built_in">append</span>(newRoot.items, upItem)</span><br><span class="line">		newRoot.children = <span class="built_in">append</span>(newRoot.children, t.root, newNode)</span><br><span class="line">		t.root = newRoot</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从根节点开始进行插入动作，</span></span><br><span class="line">	<span class="keyword">return</span> t.root.insert(item, t.MaxCap())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再跳转到node.insert部分代码看具体逻辑：就是<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">insert</span><span class="params">(item Item, maxCap <span class="keyword">int</span>)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="comment">//对node本层的item进行二分查询</span></span><br><span class="line">	<span class="comment">// 如果item已经存在，则返回item在n.items中索引位置和true</span></span><br><span class="line">	<span class="comment">// 如果不存在，则返回符合item范围的n.children数组元素索引和fasle</span></span><br><span class="line">	index, found := n.items.find(item)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果判断元素存在，则插入操作结束，返回item值</span></span><br><span class="line">	<span class="keyword">if</span> found &#123;</span><br><span class="line">		<span class="keyword">return</span> item</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果逻辑走到这里， 说明本层查询没有找到对于item</span></span><br><span class="line">	<span class="comment">// 如果已经到叶子节点,则直接插入item到目标位置</span></span><br><span class="line">	<span class="comment">/* **</span></span><br><span class="line"><span class="comment">	tips：最开始看这部门代码我时有些迷惑的，</span></span><br><span class="line"><span class="comment">	为什么这里到了叶子节点就可以直接插入呢？</span></span><br><span class="line"><span class="comment">	不用考虑叶子节点已满的情况吗？</span></span><br><span class="line"><span class="comment">	仔细缕了一边逻辑，发现时通过对跟节点的分裂判断以及后续</span></span><br><span class="line"><span class="comment">	的maybeSplitChild判断操作，保证递归到达叶子节点的时候</span></span><br><span class="line"><span class="comment">	根节点的items一定时有空余的空间可以插入的</span></span><br><span class="line"><span class="comment">	* **/</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.children) == <span class="number">0</span> &#123;</span><br><span class="line">		n.items.insertAt(index, item)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不是叶子节点，看看i处的子Node是否需要分裂， 这里的操作是为了保证后面进行插入下沉到子节点时，子节点n.children[index]一定未满</span></span><br><span class="line">	<span class="keyword">if</span> n.maybeSplitChild(index, maxCap) &#123;</span><br><span class="line">		<span class="comment">// 分裂了，导致当前node的变化，需要重新定位</span></span><br><span class="line">		<span class="comment">// 保证插入查询能下沉到items符合范围的子树中</span></span><br><span class="line">		inTree := n.items[index] <span class="comment">// 获取新升级的item</span></span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> item.Less(inTree):</span><br><span class="line">			<span class="comment">// 要插入的item比分裂产生的item小，i没改变</span></span><br><span class="line">		<span class="keyword">case</span> inTree.Less(item):</span><br><span class="line">			index++ <span class="comment">// 要插入的item比分裂产生的item大，i++</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 分裂升level的item和插入的item一致，替换</span></span><br><span class="line">			out := n.items[index]</span><br><span class="line">			n.items[index] = item</span><br><span class="line">			<span class="keyword">return</span> out</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递归插入到items符合插入范围的子树</span></span><br><span class="line">	<span class="keyword">return</span> n.children[index].insert(item, maxCap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">maybeSplitChild会对node.chilren[childIndex]进行判断，</span></span><br><span class="line"><span class="comment">如果其items已满，则进行一次分裂，将node.chilren[childIndex].items最中央的item取出插入到node.items[childIndex]的位置，</span></span><br><span class="line"><span class="comment">同时将node.chilren[childIndex]中央以后的items和children组成一个新node，插入到node.chilren[childIndex]之后</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这样做达到了两个目的：</span></span><br><span class="line"><span class="comment">1. node的items和children元素个数分别+1，保证了不破坏btree的属性</span></span><br><span class="line"><span class="comment">2. 保证了后续插入查询递归下沉到node的某一棵子树的时候，子树items未满</span></span><br><span class="line"><span class="comment">目的2特别重要，保证了插入到达子树时直接插入的合法合理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">maybeSplitChild</span><span class="params">(childIndex <span class="keyword">int</span>, maxCap <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(n.children[childIndex].items)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> l &gt;= maxCap &#123;</span><br><span class="line">		upItem, newNode := n.children[childIndex].split(l / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">		n.items.insertAt(childIndex, upItem)</span><br><span class="line">		n.children.insertAt(childIndex+<span class="number">1</span>, newNode)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// split会修改原node,导致原node的items和children减半</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tips： 这里在做split的时候，一定不要忘记了对nodechildren的split</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">split</span><span class="params">(mid <span class="keyword">int</span>)</span> <span class="params">(Item, *node)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.items)<span class="number">-1</span> &lt; mid &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"error index"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	upItem := n.items[mid]</span><br><span class="line">	newNode := &amp;node&#123;&#125;</span><br><span class="line"></span><br><span class="line">	newNode.items = <span class="built_in">append</span>(newNode.items, n.items[mid+<span class="number">1</span>:]...)</span><br><span class="line">	<span class="keyword">if</span> n.children != <span class="literal">nil</span> &#123;</span><br><span class="line">		newNode.children = <span class="built_in">append</span>(newNode.children, n.children[mid+<span class="number">1</span>:]...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n.items = n.items[:mid]</span><br><span class="line">	<span class="keyword">if</span> n.children != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.children = n.children[:mid+<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> upItem, newNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="demo"> </p><p></p>
<h4 id="插入演示"><a href="#插入演示" class="headerlink" title="插入演示"></a>插入演示</h4><p>exp1：空树直接插入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">最小度为2的树（2-3-4树）插入例子：</span><br><span class="line"> item:1</span><br><span class="line"> 原btree:</span><br><span class="line">	|  |</span><br><span class="line">判断为空树，直接插入root.items,结束</span><br><span class="line"> 新btree:</span><br><span class="line">	| 1 |</span><br></pre></td></tr></table></figure></p>
<p>exp2: 根直接插入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> item: 3</span><br><span class="line"> 原树:</span><br><span class="line">	| 1 | 2 |</span><br><span class="line"></span><br><span class="line">step1,判断root.items是否已满，已满则进行分裂（未满，不分裂）</span><br><span class="line">step2,执行root.insert,发现已经是最底一层，直接插入（step1保证step2直接插入不破坏tree属性定义）</span><br><span class="line"> output:</span><br><span class="line">	| 1 | 2 |   =》直接插入</span><br><span class="line">		 </span><br><span class="line">	| 1 | 2 | 3 | （stop）</span><br></pre></td></tr></table></figure></p>
<p>exp3: 插入触发根分裂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> item: 4</span><br><span class="line"> 原树:</span><br><span class="line">	| 1 | 2 | 3 |</span><br><span class="line"></span><br><span class="line">step1：判断root.items是否已满，已满则进行分裂(已满，需要分裂)</span><br><span class="line"></span><br><span class="line">| 1 | 2 | 3 |    （原tree） </span><br><span class="line"></span><br><span class="line">   |  2  |</span><br><span class="line">  /       \         (分裂后新的btree)  </span><br><span class="line">| 1 |    | 3 |</span><br><span class="line"></span><br><span class="line">step2: 对新的btree执行插入操作，进入第一层,第一层查询未找到，</span><br><span class="line">进入chilren[1],判断chilren[1]是否需要进行分裂处理（不需要）</span><br><span class="line"></span><br><span class="line">step3: 对children[i]进行item插入操作，发现为子节点，直接插入。</span><br><span class="line">操作前 children[1]: | 3 |</span><br><span class="line">插入后chilren[1]:  | 3 | 4 |</span><br><span class="line"></span><br><span class="line">插入结束，此时btree最终形态为：</span><br><span class="line">   |  2  |</span><br><span class="line">  /       \         </span><br><span class="line">| 1 |    | 3 | 4 |</span><br></pre></td></tr></table></figure>
<p>exp4:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">item:5</span><br><span class="line">原树：   </span><br><span class="line">   |  2  |</span><br><span class="line">  /       \         </span><br><span class="line">| 1 |    | 3 | 4 |</span><br><span class="line"></span><br><span class="line">step1:根是否已满判断（未满，接着执行root.insert）</span><br><span class="line"></span><br><span class="line">step2: 进入第一层查询，f返回index1, d对node.chilren[1]进行是否已满判断（未满）</span><br><span class="line"></span><br><span class="line">step3: 递归进入node.chilre[1],发现到达根节点，直接插入</span><br><span class="line">原node: | 3 | 4 | </span><br><span class="line">新node: | 3 | 4 | 5 |</span><br><span class="line">插入结束，此时的btree最终形态如下：</span><br><span class="line">   |  2  |</span><br><span class="line">  /       \         </span><br><span class="line">| 1 |    | 3 | 4 | 5 |</span><br></pre></td></tr></table></figure>
<p>exp5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">item:6</span><br><span class="line">原树：   </span><br><span class="line">   |  2  |</span><br><span class="line">  /       \         </span><br><span class="line">| 1 |    | 3 | 4 | 5 |</span><br><span class="line"></span><br><span class="line">step1:根是否已满判断（未满，接着执行root.insert）</span><br><span class="line"></span><br><span class="line">step2: 进入第一层查询，f返回index1, d对node.children[1]进行是否已满判断</span><br><span class="line">（已满，对node节点在1处执行分裂），</span><br><span class="line">执行完分裂后，树的形态如下，同时下降的子树index+1,插入下沉到node.children[2],即|5|：</span><br><span class="line"></span><br><span class="line">   |  2  |  4  |</span><br><span class="line">  /       \     \    </span><br><span class="line">| 1 |    | 3 |   | 5 |</span><br><span class="line"></span><br><span class="line">step3: 递归到node.chilren[2]作为新的node执行insert item, 发现已经到叶子，直接插入</span><br><span class="line">插入前node： | 5 |</span><br><span class="line">插入后node： | 5 | 6 |</span><br><span class="line">插入结束，返回nil, 此时btre最终形态如下：</span><br><span class="line">   |  2  |  4  |</span><br><span class="line">  /       \     \    </span><br><span class="line">| 1 |    | 3 |   | 5 | 6 |</span><br></pre></td></tr></table></figure></p>
<p>exp6:<br>接着插入7的过程和exp5一致，略过，来看插入8:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">item: 8</span><br><span class="line">原树：    </span><br><span class="line">    |  2  |  4  |</span><br><span class="line">   /       \     \    </span><br><span class="line">  |1|      |3|   |5|6|7|</span><br><span class="line"></span><br><span class="line">step1:根是否已满判断（未满，接着执行root.insert）</span><br><span class="line"></span><br><span class="line">step2: 进入第一层查询，f返回index = 2 , d对node.children[2 ]进行是否已满判断</span><br><span class="line">（已满，对node节点在2处执行分裂，分裂后index = 3,分裂后结果如下：</span><br><span class="line"></span><br><span class="line">    |  2  |  4  |  6  |</span><br><span class="line">   /       \     \     \   </span><br><span class="line"> |1|       |3|   |5|   |7|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">step3: 经过step2之后，插入递归到下一层，也就是 |7|这里，发现是叶子，直接插入</span><br><span class="line">插入前节点： | 7 |</span><br><span class="line">插入后节点： | 7 | 8 |</span><br><span class="line">插入结束，返回nil,此时最终的btre形态为</span><br><span class="line">    |  2  |  4  |  6  |</span><br><span class="line">   /       \     \     \   </span><br><span class="line"> |1|       |3|   |5|   |7|8|</span><br></pre></td></tr></table></figure></p>
<p>exp7:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">item: 9</span><br><span class="line">原树：    </span><br><span class="line">    |  2  |  4  |  6  |</span><br><span class="line">   /       \     \     \   </span><br><span class="line"> |1|       |3|   |5|   |7|8|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">step1: 根已满，进行根分裂，分裂后btree:</span><br><span class="line">         |   4   |</span><br><span class="line">        /         \ </span><br><span class="line">    | 2 |         | 6 |</span><br><span class="line">   /     \       /     \   </span><br><span class="line"> |1|     |3|   |5|      |7|8|</span><br><span class="line"></span><br><span class="line"> step2: 对分裂后的新树执行从根执行insert，</span><br><span class="line"> 	进入第一层，未找到，index = 1 ，root.children[1]未满，进入下一层</span><br><span class="line"> step3: 依次递归进入第二层 | 6 |， 第三层 | 7| 8|此时已经到叶子，直接插入</span><br><span class="line"></span><br><span class="line">插入前node : |7|8|,</span><br><span class="line">插入后node: |7|8|9|</span><br><span class="line">插入结束，返回nil，最终的btree如下：</span><br><span class="line"></span><br><span class="line">         |   4   |</span><br><span class="line">        /         \ </span><br><span class="line">    | 2 |         | 6 |</span><br><span class="line">   /     \       /     \   </span><br><span class="line"> |1|     |3|   |5|      |7|8|9|</span><br></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/25/201812btree-1/" rel="next" title="由一个golang的B-Tree包展开-1(属性介绍)">
                <i class="fa fa-chevron-left"></i> 由一个golang的B-Tree包展开-1(属性介绍)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/28/201812btree-3/" rel="prev" title="由一个golang的B-Tree包展开-3(删除元素)">
                由一个golang的B-Tree包展开-3(删除元素) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://img3.doubanio.com/icon/ul54452955-3.jpg" alt="不知火">
          <p class="site-author-name" itemprop="name">不知火</p>
           
              <p class="site-description motion-element" itemprop="description">梦见它们都在草地上吃草</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">42</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/54452955" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree结构定义及初始化"><span class="nav-number">1.</span> <span class="nav-text">B-Tree结构定义及初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree中插入新数据"><span class="nav-number">2.</span> <span class="nav-text">B-Tree中插入新数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例代码"><span class="nav-number">2.1.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入的思路"><span class="nav-number">2.2.</span> <span class="nav-text">插入的思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#配套函数"><span class="nav-number">2.3.</span> <span class="nav-text">配套函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入逻辑实现"><span class="nav-number">2.4.</span> <span class="nav-text">插入逻辑实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入演示"><span class="nav-number">2.5.</span> <span class="nav-text">插入演示</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不知火</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://buqisuitu.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2018/12/25/201812btree-2/';
          this.page.identifier = '2018/12/25/201812btree-2/';
          this.page.title = '由一个golang的B-Tree包展开-2(插入)';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://buqisuitu.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  





  






  





  

  

  

  

</body>
</html>
